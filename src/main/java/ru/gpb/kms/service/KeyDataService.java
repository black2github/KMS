package ru.gpb.kms.service;

import ru.gpb.kms.entity.Dto.KeyDataDto;
import ru.gpb.kms.entity.KeyStatus;

import javax.crypto.SecretKey;
import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;

/**
 * Key Data interface.
 */
public interface KeyDataService {

    /**
     * Получение списка всех ключей.
     * @return список DTO с данными по ключам.
     */
    List<KeyDataDto> listAll();

    /**
     * Получение списка идентификаторов ключей в оперативном доступе.
     * @return список идентификаторов ключей в оперативном доступе.
     */
    List<String> listCache();

    /**
     * Обновление атрибутов ключа.
     * @param id строка с идентификатором обновляемого ключа.
     * @param keyDataDto данные, которыми нунжно обновить ключ.
     */
    void updateKeyData(String id, KeyDataDto keyDataDto);

    /**
     * Изменение статуса ключа.
     * @param id строка с идентификатором ключа.
     * @param newStatus новый статус.
     */
    void changeStatus(String id, KeyStatus newStatus);

    /**
     * Отметить ключ на удаление.
     * @param id строка с идентификатором удаляемого ключа.
     */
    void delete(String id);

    /**
     * Получение секретного ключа шифрования данных в открытом виде. Служебный метод, НЕ
     * предназначен для "внешнего" использвоания.
     * @param id идентификатор расшифруемого ключа.
     * @return секретный ключ, который можно использовать для шифрования или расшифровки.
     */
    SecretKey decodeDataKey(UUID id);

    /**
     * Создание ключа шифрования данных.
     * @param alias адиас ключа, с которым он будет помещен в хранилище.
     * @return DTO с данными созданного ключа.
     */
    KeyDataDto generateDataKey(String alias);

    /**
     * Загрузка мастер-ключа. Для загрузки требуется вызвать данный метод двумя разными пользователями,
     * каждый из которых предоставляет свой пароль для доступа к ключу. Порядок вызова метода каждым из
     * пользователей должен совпадать порядок, использованным для генерации этого ключа.
     *
     * @param id идентификатор загружаемого ключа.
     * @param password пароль для загрузки ключа, указываемый текущим пользователем.
     * @return DTO с данными загруженного мастер ключа. Сам ключ - не возращается, DTO содержит ссылку (URI) на хранилище,
     * в котором находится ключ.
     */
    KeyDataDto loadMasterKey(UUID id, char[] password);

    /**
     * Создание мастер-ключа. Для загрузки требуется вызвать данный метод двумя разными пользователями,
     * каждый из которых предоставляет свой пароль для доступа к ключу. Важно запонить не только пароли
     * пользователей, но и порядок вызова (какой пользователь первым, какой - вторым). При загрузке ключа
     * потребуется возпроизвести этот же порядок вызова.
     *
     * @param id Идентификатор ключа. Пустой в случае вызова первым пользователем и содержащий идентификатор
     *           создаваемого ключа (в статусе "ожидает создания") при вызове вторым пользователем.
     * @param alias Алиас (необязательный), под которым ключ будет помещен в храналище.
     * @param desc Описание (необязательный) ключа.
     * @param expirationDate Срок действия (необязательный). Если не указан, будет взят из настройки.
     * @param password Пароль для доступа к ключу.
     * @param notifyDate Срок уведомления об истечении срока действия (необязательный).
     * @return DTO с данными созданного мастер-ключа. DTO в поле Ключ содержит ссылку (URI) на место размещения ключа.
     */
    KeyDataDto generateMasterKey(UUID id, String alias, String desc, LocalDateTime expirationDate,
                            char[] password, LocalDateTime notifyDate);


    /**
     * Перешифровка ключей шифрования данных. Метод, вызываемый с определенной периодичностью для ротации ключей.
     */
    void rotateDataKey();
}
